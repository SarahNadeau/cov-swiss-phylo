---
title: post-processing
---

* need to have run "preprocessing.Rmd" first to generate files "sampPropChangeTimes.txt" and "ReChangeTimes.txt"

```{r }
library(tidyverse)
library(lubridate)
library(ggdist)
library(ggplot2)
library(dplyr)
library(readr)
library(tidyr)

source("scripts/figures_shared_vars.R")
system(command = "mkdir -p figures")

datadir <- "results_all/bdsky/log_files/SwissTransmissionChains/results/"
```

## Load data

```{r }
skyline_data <- NULL
for (clusters in c("min", "max")) {
    for (contact_tracing in c(TRUE, FALSE)) {
        for (sampUB in c("With sampling bound", "Without sampling bound" )) {
            pattern <- paste0("Re_skyline.", clusters, "_chains",
                              ".sampUB", ifelse(sampUB=="With sampling bound", "0.05", "1.0"),
                              ".", ifelse(contact_tracing, "1", "0"),
                              ".*.log")

            data <- NULL
            for (f in dir(datadir, pattern, full.names=TRUE)) {
                print(f)
                data <- bind_rows(data, read_tsv(f) %>% slice_tail(prop=0.9))
            }

            Re_temp_data <- data %>%
                pivot_longer(cols=starts_with("ReValues."),
                             names_to="interval", values_to="value",
                             names_prefix="ReValues.",
                             names_transform=list(interval=as.integer)) %>%
                select(Sample, interval, value) %>%
                mutate(variable="Re")

            sampProp_temp_data <- data %>%
                pivot_longer(cols=starts_with("sampValues."),
                             names_to="interval", values_to="value",
                             names_prefix="sampValues.",
                             names_transform=list(interval=as.integer)) %>%
                select(Sample, interval, value) %>%
                mutate(variable="sampProp")

            skyline_temp_data <- bind_rows(Re_temp_data, sampProp_temp_data) %>%
                group_by(interval, variable) %>%
                summarize(median=median(value),
                          low=quantile(value, 0.025),
                          high=quantile(value, 0.975)) %>%
                mutate(clusters=clusters,
                       contact_tracing=contact_tracing,
                       sampUB=sampUB)

            skyline_data <- bind_rows(skyline_data, skyline_temp_data)
        }
    }
}
```

## Incoroporate interval dates

```{r }
finalSampleDate <- ymd("2020-11-30")
day_to_week <- read_csv(paste0(datadir, "/../sequences/date_to_week.csv"))
Re_dates <- day_to_week %>%
    distinct(week) %>%
    filter(week<finalSampleDate) %>%
    arrange(desc(row_number())) %>%
    transmute(interval=row_number(), date=week + 3.5)  # dates are the start of each interval, make the midpoint

sampProp_dates <- read_csv(paste0(datadir, "/../sampPropChangeTimes.txt"), col_names=c("age")) %>%
    add_row(age=0) %>%
    mutate(date=finalSampleDate - 365.25*age) %>%
    arrange(age) %>%
    mutate(interval=row_number())
```

## Load case count data

```{r}
LINE_LIST_RE_EST_LINK <- "https://github.com/covid-19-Re/dailyRe-Data/raw/fbe982f48a0e8220460b1f1701a74ee7390e1fdc/CHE-estimates.csv"  # take March 2022 version of data where early estimates still made for CHE
line_list_re_data <- read.csv(file = LINE_LIST_RE_EST_LINK) %>%
  filter(
    region == "CHE",
    data_type == "Confirmed cases", 
    estimate_type == "Cori_slidingWindow") %>%
  select(c(date, data_type, median_R_mean, median_R_highHPD, median_R_lowHPD)) %>%
  mutate(date = as.Date(date)) %>%
  rename(
    median = median_R_mean,
    yhigh = median_R_highHPD,
    ylow = median_R_lowHPD)
```

## Plot skylines

**In the final plots, make sure to add monthly/bi-weekly axis ticks.**

```{r}
color_values <- c("conf_case_counts" = "grey", "TRUE" = model_type_colors[1], "FALSE" =  model_type_colors[2])
color_labels_re <- c("conf_case_counts" = "Estimate based on\nconfirmed cases", 
                  "TRUE" = "Pre-damping estimate based\non model with damping factor", 
                  "FALSE" = "Estimate based on model\nwithout damping factor")
color_labels_s <- c("TRUE" = "Estimate based\non model with damping factor", 
                  "FALSE" = "Estimate based on model\nwithout damping factor")

start_plot_date <- as.Date("2020-02-20")  # plot from first week we have data
stop_plot_date <- as.Date("2020-11-30")  # plot until end of sampling period

# Repeat last week so that final ribbon shows
re_data <- skyline_data %>% filter(variable=="Re") %>% left_join(Re_dates)
last_week_data <- re_data %>% filter(interval == 1) %>% mutate(date = stop_plot_date)
re_data_to_plot <- rbind(re_data, last_week_data) 

re_plot <- ggplot(re_data_to_plot,
       aes(date, median, fill = contact_tracing, color = contact_tracing)) +
    tidybayes::geom_lineribbon(
        aes(ymin=low, ymax=high), alpha=0.5, step = "mid") +  # dates are the midpoint of each interval
    geom_ribbon(
        data = line_list_re_data, 
        aes(date, ymin=ylow, ymax=yhigh, fill = 'conf_case_counts', color = 'conf_case_counts'), alpha = 0.5) + 
    geom_line(data = line_list_re_data, aes(color = 'conf_case_counts'), alpha = 0.5) +
    scale_color_manual(name = NULL, values = color_values, labels = color_labels_re) + 
    scale_fill_manual(name = NULL, values = color_values, labels = color_labels_re) + 
    # geom_hline(yintercept=1, linetype="dashed") +
    facet_grid(rows=vars(clusters), cols=vars(sampUB), scales="free", labeller = labeller(clusters = chain_assumption_labs)) +
    scale_x_date(date_breaks="1 month", date_labels="%b", limits = c(start_plot_date, stop_plot_date)) +
    labs(y = "Effective reproductive number", x = element_blank()) + 
    shared_theme + 
    theme(legend.position = "bottom")
ggsave("figures/CHE_Re.pdf", width=double_col_width, height=single_col_width, units="cm")

# Repeat first week so that first ribbon shows
samp_prop_data <- skyline_data %>% filter(variable=="sampProp") %>% left_join(sampProp_dates)
max_interval <- max(samp_prop_data$interval)
first_week_data <- samp_prop_data %>% filter(interval == max_interval) %>% mutate(date = start_plot_date)
samp_prop_data <- rbind(samp_prop_data, first_week_data)

samp_prop_plot <- ggplot(samp_prop_data,
       aes(date, median, col=contact_tracing, fill=contact_tracing)) +
    tidybayes::geom_lineribbon(aes(ymin=low, ymax=high), alpha=0.5, step="vh") +  # dates are endpoint of each interval
    scale_color_manual(name = NULL, values = color_values, labels = color_labels_s, limits = c("TRUE", "FALSE")) + 
    scale_fill_manual(name = NULL, values = color_values, labels = color_labels_s, limits = c("TRUE", "FALSE")) + 
    facet_grid(rows=vars(clusters), cols=vars(sampUB), scales="free", labeller = labeller(clusters = chain_assumption_labs)) +
    scale_x_date(date_breaks="1 month", date_labels="%b", limits = c(start_plot_date, stop_plot_date)) +
    labs(y = "Sampling probability", x = element_blank()) + 
    lims(y = c(0, 1)) + 
    geom_hline(data = . %>% filter(interval == 1, sampUB == "With sampling bound"), aes(yintercept = 0.05), linetype = "dashed") + 
    shared_theme + 
    theme(legend.position = "bottom")
ggsave("figures/CHE_sampProp.pdf", width=double_col_width, height=single_col_width, units="cm")
```

Arrange plots together
```{r}
require(cowplot)

plot_grid(samp_prop_plot, re_plot,
          nrow = 2, ncol = 1,
          width = double_col_width,
          labels = c("A", "B")
)

ggsave(
        filename = "figures/CHE_phylodynamic_results.png",
        width = double_col_width,
        height = single_col_width * 1.75,
        units = "cm"
)
```

## Contact tracing effect size

```{r }

CT_data <- NULL
for (clusters in c("min", "max")) {
    for (contact_tracing in c(TRUE, FALSE)) {
        for (sampUB in c("With sampling bound", "Without sampling bound" )) {
            pattern <- paste0("Re_skyline.", clusters, "_chains",
                              ".sampUB", ifelse(sampUB=="With sampling bound", "0.05", "1.0"),
                              ".", ifelse(contact_tracing, "1", "0"),
                              ".*.log")

            data <- NULL
            for (f in dir("results", pattern, full.names=TRUE)) {
                data <- bind_rows(data, read_tsv(f) %>% slice_tail(prop=0.9))
            }

            CT_data <- bind_rows(CT_data,
                                 data %>%
                                 slice_tail(prop=0.9) %>%
                                 select(Sample, "CTFactor[0]", "CTFactor[1]", "CTFactor[2]") %>%
                                 pivot_longer(cols=2:4) %>%
                                 mutate(lessThanOne=(value<1.0)) %>%
                                 mutate(clusters=clusters,
                                        contact_tracing=contact_tracing,
                                        sampUB=sampUB))
        }
    }
}

```

## All-analyses damping factor figure for supplemental

```{r}

CT_data <- CT_data %>%
  mutate(season = case_when(
    name == "CTFactor[0]" ~ "Fall",
    name == "CTFactor[1]" ~ "Summer",
    name == "CTFactor[2]" ~ "Spring"), 
  season = factor(season, levels = c("Spring", "Summer", "Fall")),
  transmission_rate_decrease = (1 - value) * 100)

ggplot() +  
  geom_histogram(
    data = CT_data %>% filter(contact_tracing == "TRUE", clusters == "max"), 
    aes(x = transmission_rate_decrease, fill = clusters), alpha = 0.5, bins = 30) + 
  geom_histogram(
    data = CT_data %>% filter(contact_tracing == "TRUE", clusters == "min"), 
    aes(x = transmission_rate_decrease, fill = clusters), alpha = 0.5, bins = 30) + 
  facet_grid(season ~ sampUB) + 
  scale_fill_manual(values = chains_assumption_colors, labels = chain_assumption_labs, name = chains_assumption_legend_name) + 
  shared_theme + 
  labs(x = ct_factor_x_lab, y = ct_factor_y_lab)

ggsave("figures/contact_tracing_factor.pdf", width = double_col_width, height = single_col_width * 0.75, units = "cm")
```

## Write out variables for manuscript, copy figures into manuscript figure directory

```{r}
re_data <- skyline_data %>% filter(variable=="Re") %>% left_join(Re_dates)
re_peak <- re_data %>% group_by(clusters, contact_tracing, sampUB) %>% top_n(n = 1, wt = median)
re_after_peak <- re_data %>% filter(date == re_peak$date[[1]] + 7)

if (length(unique(re_peak$date)) != 1 | length(unique(re_after_peak$date)) != 1) {
  stop("Week results in re_estimates.text won't be right, code doesn't handle max/mins on different weeks.")
}

con1 <- file("../../../../manuscript/re_estimates.tex", open = "w")
repeakmin <- round(min(re_peak$median), digits = 1)
repeakmax <- round(max(re_peak$median), digits = 1)
reafterpeakmin <- round(min(re_after_peak$median), digits = 1)
reafterpeakmax <- round(max(re_after_peak$median), digits = 1)
repeakweek <- unique(re_peak$date)
reafterpeakweek <- unique(re_after_peak$date)

writeLines(text = paste0("\\newcommand\\repeakmin{", repeakmin, "}"), con = con1)
writeLines(text = paste0("\\newcommand\\repeakmax{", repeakmax, "}"), con = con1)
writeLines(text = paste0("\\newcommand\\reafterpeakmin{", reafterpeakmin, "}"), con = con1)
writeLines(text = paste0("\\newcommand\\reafterpeakmax{", reafterpeakmax, "}"), con = con1)
writeLines(text = paste0("\\newcommand\\repeakweek{", repeakweek, "}"), con = con1)
writeLines(text = paste0("\\newcommand\\reafterpeakweek{", reafterpeakweek, "}"), con = con1)
close(con1)

con <- file("../../../../manuscript/damping_factor_variables.tex", open = "w")

damping_factor_medians <- CT_data %>%
  filter(contact_tracing == "TRUE") %>%
  group_by(sampUB, clusters, season) %>%
  summarize(median_damping_factor = median(value), .groups = "drop")

summer_max_damping_percent_median_CHE_no_sampUB <- round(1 - unlist(damping_factor_medians %>%
  filter(sampUB == "Without sampling bound", clusters == "max", season == "Summer") %>%
  select(median_damping_factor)) * 100, digits = 0)

writeLines(text = paste0("\\newcommand\\summermaxdampingpercentmedianCHEnosampUB{", 
                         summer_max_damping_percent_median_CHE_no_sampUB, "}"), con = con)

summer_min_damping_percent_median_CHE_no_sampUB <- round(1 - unlist(damping_factor_medians %>%
  filter(sampUB == "Without sampling bound", clusters == "min", season == "Summer") %>%
  select(median_damping_factor)) * 100, digits = 0)

writeLines(text = paste0("\\newcommand\\summermindampingpercentmedianCHEnosampUB{", 
                         summer_min_damping_percent_median_CHE_no_sampUB, "}"), con = con)

close(con)

system("cp figures/contact_tracing_factor.pdf ../../../../figures/CHE_contact_tracing_factor.pdf")
system("cp figures/sampProp.pdf ../../../../figures/CHE_sampProp.pdf")
system("cp figures/Re.pdf ../../../../figures/CHE_Re.pdf")
```

Write out median Re estimates for correcting introduction estimates.
Use estimates without damping factor, without sampling bound
Dates are start of interval
```{r}
day_to_week <- read_csv(paste0(datadir, "/../sequences/date_to_week.csv"))
Re_dates <- day_to_week %>%
    distinct(week) %>%
    filter(week<finalSampleDate) %>%
    arrange(desc(row_number())) %>%
    transmute(interval=row_number(), date=week)  # dates are the start of each interval

re_data_all <- skyline_data %>% filter(variable=="Re") %>% left_join(Re_dates)
re_data_to_use <- re_data_all %>%
  filter(sampUB == "Without sampling bound", !contact_tracing)
write.csv(
  x = re_data_to_use,
  file = paste0(datadir, "/../re_by_interval_start.csv"),
  row.names = F
)
```